<!-- Copyright (C) 2003 Red Hat, Inc.                                -->
<!-- This material may be distributed only subject to the terms      -->
<!-- and conditions set forth in the Open Publication License, v1.0  -->
<!-- or later (the latest version is presently available at          -->
<!-- http://www.opencontent.org/openpub/).                           -->
<!-- Distribution of the work or derivative of the work in any       -->
<!-- standard (paper) book form is prohibited unless prior           -->
<!-- permission is obtained from the copyright holder.               -->
<HTML
><HEAD
><TITLE
>Interrupt Handling</TITLE
><meta name="MSSmartTagsPreventParsing" content="TRUE">
<META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="eCos Reference Manual"
HREF="ecos-ref.html"><LINK
REL="UP"
TITLE="HAL Interfaces"
HREF="hal-interfaces.html"><LINK
REL="PREVIOUS"
TITLE="Architecture Characterization"
HREF="hal-architecture-characterization.html"><LINK
REL="NEXT"
TITLE="HAL I/O"
HREF="hal-input-and-output.html"></HEAD
><BODY
CLASS="SECTION"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>eCos Reference Manual</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="hal-architecture-characterization.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. HAL Interfaces</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="hal-input-and-output.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECTION"
><H1
CLASS="SECTION"
><A
NAME="HAL-INTERRUPT-HANDLING">Interrupt Handling</H1
><P
>These interfaces contain definitions related to interrupt
handling. They include definitions of exception and interrupt numbers,
interrupt enabling and masking, and realtime clock operations.</P
><P
>These definitions are normally found in
<TT
CLASS="FILENAME"
>cyg/hal/hal_intr.h</TT
>.  This file is supplied by the
architecture HAL.  Any variant or platform specific definitions will
be found in <TT
CLASS="FILENAME"
>cyg/hal/var_intr.h</TT
>,
<TT
CLASS="FILENAME"
>cyg/hal/plf_intr.h</TT
> or
<TT
CLASS="FILENAME"
>cyg/hal/hal_platform_ints.h</TT
> in the variant or platform
HAL, depending on the exact target. These files are include
automatically by this header, so need not be included explicitly.</P
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN7921">Vector numbers</H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CYGNUM_HAL_VECTOR_XXXX
CYGNUM_HAL_VSR_MIN
CYGNUM_HAL_VSR_MAX
CYGNUM_HAL_VSR_COUNT

CYGNUM_HAL_INTERRUPT_XXXX
CYGNUM_HAL_ISR_MIN
CYGNUM_HAL_ISR_MAX
CYGNUM_HAL_ISR_COUNT

CYGNUM_HAL_EXCEPTION_XXXX
CYGNUM_HAL_EXCEPTION_MIN
CYGNUM_HAL_EXCEPTION_MAX
CYGNUM_HAL_EXCEPTION_COUNT</PRE
></TD
></TR
></TABLE
><P
>All possible VSR, interrupt and exception vectors are specified here,
together with maximum and minimum values for range checking. While the
VSR and exception numbers will be defined in this file, the interrupt
numbers will normally be defined in the variant or platform HAL file
that is included by this header. </P
><P
>There are two ranges of numbers, those for the vector service
routines and those for the interrupt service routines. The relationship
between these two ranges is undefined, and no equivalence should
be assumed if vectors from the two ranges coincide.</P
><P
>The VSR vectors correspond to the set of exception vectors that can be
delivered by the CPU architecture, many of these will be internal
exception traps. The ISR vectors correspond to the set of external
interrupts that can be delivered and are usually determined by extra
decoding of the interrupt controller by the interrupt VSR.</P
><P
>Where a CPU supports synchronous exceptions, the range of such
exceptions allowed are defined by <TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_MIN</TT
> and
<TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_MAX</TT
>. The
<TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_XXXX</TT
> definitions are
standard names used by target independent code to test for the
presence of particular exceptions in the architecture. The actual
exception numbers will normally correspond to the VSR exception
range. In future other exceptions generated by the system software
(such as stack overflow) may be added.</P
><P
><TT
CLASS="LITERAL"
>CYGNUM_HAL_ISR_COUNT</TT
>, <TT
CLASS="LITERAL"
>CYGNUM_HAL_VSR_COUNT</TT
> and
<TT
CLASS="LITERAL"
>CYGNUM_HAL_EXCEPTION_COUNT</TT
> define the number of
ISRs, VSRs and EXCEPTIONs respectively for the purposes of defining
arrays etc. There might be a translation from the supplied vector
numbers into array offsets. Hence
<TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_COUNT</TT
> may not simply be
<TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_MAX</TT
> - <TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_MIN</TT
> or <TT
CLASS="LITERAL"
>CYGNUM_HAL_XXX_MAX</TT
>&#0043;1.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN7939">Interrupt state control</H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>CYG_INTERRUPT_STATE
HAL_DISABLE_INTERRUPTS( old )
HAL_RESTORE_INTERRUPTS( old )
HAL_ENABLE_INTERRUPTS()
HAL_QUERY_INTERRUPTS( state )</PRE
></TD
></TR
></TABLE
><P
>These macros provide control over the state of the CPUs interrupt mask
mechanism. They should normally manipulate a CPU status register to
enable and disable interrupt delivery. They should not access an
interrupt controller.</P
><P
><TT
CLASS="LITERAL"
>CYG_INTERRUPT_STATE</TT
> is a data type that should be
used to store the interrupt state returned by
<TT
CLASS="FUNCTION"
>HAL_DISABLE_INTERRUPTS()</TT
> and
<TT
CLASS="FUNCTION"
>HAL_QUERY_INTERRUPTS()</TT
> and passed to
<TT
CLASS="FUNCTION"
>HAL_RESTORE_INTERRUPTS()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>HAL_DISABLE_INTERRUPTS()</TT
> disables the delivery of
interrupts and stores the original state of the interrupt mask in the
variable passed in the <TT
CLASS="PARAMETER"
><I
>old</I
></TT
> argument.</P
><P
><TT
CLASS="FUNCTION"
>HAL_RESTORE_INTERRUPTS()</TT
> restores the state of
the interrupt mask to that recorded in <TT
CLASS="PARAMETER"
><I
>old</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>HAL_ENABLE_INTERRUPTS()</TT
> simply enables interrupts
regardless of the current state of the mask.</P
><P
><TT
CLASS="FUNCTION"
>HAL_QUERY_INTERRUPTS()</TT
> stores the state of the
interrupt mask in the variable passed in the <TT
CLASS="PARAMETER"
><I
>state</I
></TT
> argument. The state stored here should also be
capable of being passed to
<TT
CLASS="FUNCTION"
>HAL_RESTORE_INTERRUPTS()</TT
> at a later point.</P
><P
>It is at the HAL implementer&#8217;s discretion exactly
which interrupts are masked by this mechanism. Where a CPU has more
than one interrupt type that may be masked separately (e.g. the
ARM's IRQ and FIQ) only those that can raise DSRs need
to be masked here. A separate architecture specific mechanism may
then be used to control the other interrupt types.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN7961">ISR and VSR management</H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>HAL_INTERRUPT_IN_USE( vector, state )
HAL_INTERRUPT_ATTACH( vector, isr, data, object )
HAL_INTERRUPT_DETACH( vector, isr )
HAL_VSR_SET( vector, vsr, poldvsr )
HAL_VSR_GET( vector, pvsr )
HAL_VSR_SET_TO_ECOS_HANDLER( vector, poldvsr )</PRE
></TD
></TR
></TABLE
><P
>These macros manage the attachment of interrupt and vector service
routines to interrupt and exception vectors respectively.</P
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_IN_USE()</TT
> tests the state of the
supplied interrupt vector and sets the value of the state parameter to
either 1 or 0 depending on whether there is already an ISR attached to
the vector. The HAL will only allow one ISR to be attached to each
vector, so it is a good idea to use this function before using
<TT
CLASS="FUNCTION"
>HAL_INTERRUPT_ATTACH()</TT
>.</P
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_ATTACH()</TT
> attaches
the ISR, data pointer and object pointer to the given
<TT
CLASS="PARAMETER"
><I
>vector</I
></TT
>. When an interrupt occurs on this
vector the ISR is called using the C calling convention and the vector
number and data pointer are passed to it as the first and second
arguments respectively.</P
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_DETACH()</TT
> detaches the ISR from the
vector.</P
><P
><TT
CLASS="FUNCTION"
>HAL_VSR_SET()</TT
> replaces the VSR attached to the
<TT
CLASS="PARAMETER"
><I
>vector</I
></TT
> with the replacement supplied in
<TT
CLASS="PARAMETER"
><I
>vsr</I
></TT
>. The old VSR is returned in the location
pointed to by <TT
CLASS="PARAMETER"
><I
>pvsr</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>HAL_VSR_GET()</TT
> assigns
a copy of the VSR to the location pointed to by <TT
CLASS="PARAMETER"
><I
>pvsr</I
></TT
>.</P
><P
><TT
CLASS="FUNCTION"
>HAL_VSR_SET_TO_ECOS_HANDLER()</TT
> ensures that the
VSR for a specific exception is pointing at the eCos exception VSR and
not one for RedBoot or some other ROM monitor. The default when
running under RedBoot is for exceptions to be handled by RedBoot and
passed to GDB. This macro diverts the exception to eCos so that it may
be handled by application code. The arguments are the VSR vector to be
replaces, and a location in which to store the old VSR pointer, so
that it may be replaced at a later point.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN7983">Interrupt controller management</H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>HAL_INTERRUPT_MASK( vector )
HAL_INTERRUPT_UNMASK( vector )
HAL_INTERRUPT_ACKNOWLEDGE( vector )
HAL_INTERRUPT_CONFIGURE( vector, level, up )
HAL_INTERRUPT_SET_LEVEL( vector, level )</PRE
></TD
></TR
></TABLE
><P
>These macros exert control over any prioritized interrupt
controller that is present. If no priority controller exists, then
these macros should be empty.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>  These macros may not be reentrant, so care should be taken to
  prevent them being called while interrupts are enabled. This means
  that they can be safely used in initialization code before
  interrupts are enabled, and in ISRs. In DSRs, ASRs and thread code,
  however, interrupts must be disabled before these macros are
  called. Here is an example for use in a DSR where the interrupt
  source is unmasked after data processing:
  </P
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> ...
 HAL_DISABLE_INTERRUPTS(old);
 HAL_INTERRUPT_UNMASK(CYGNUM_HAL_INTERRUPT_ETH);
 HAL_RESTORE_INTERRUPTS(old);
 ...</PRE
></TD
></TR
></TABLE
></BLOCKQUOTE
></DIV
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_MASK()</TT
> causes the interrupt
associated with the given vector to be blocked.</P
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_UNMASK()</TT
> causes the interrupt
associated with the given vector to be unblocked.</P
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_ACKNOWLEDGE()</TT
> acknowledges the
current interrupt from the given vector. This is usually executed from
the ISR for this vector when it is prepared to allow further
interrupts.  Most interrupt controllers need some form of acknowledge
action before the next interrupt is allowed through. Executing this
macro may cause another interrupt to be delivered. Whether this
interrupts the current code depends on the state of the CPU interrupt
mask.</P
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_CONFIGURE()</TT
> provides
control over how an interrupt signal is detected. The arguments
are:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>vector</DT
><DD
><P
>The interrupt vector to be configured.</P
></DD
><DT
>level</DT
><DD
><P
>      Set to <TT
CLASS="VARNAME"
>true</TT
> if the interrupt is detected by
      level, and <TT
CLASS="VARNAME"
>false</TT
> if it is edge triggered.
      </P
></DD
><DT
>up</DT
><DD
><P
>      If the interrupt is set to level detect, then if this is
      <TT
CLASS="VARNAME"
>true</TT
> it is detected by a high signal level,
      and if <TT
CLASS="VARNAME"
>false</TT
> by a low signal level. If the
      interrupt is set to edge triggered, then if this is
      <TT
CLASS="VARNAME"
>true</TT
> it is triggered by a rising edge and if
      <TT
CLASS="VARNAME"
>false</TT
> by a falling edge.
      </P
></DD
></DL
></DIV
><P
><TT
CLASS="FUNCTION"
>HAL_INTERRUPT_SET_LEVEL()</TT
> provides control over
the hardware priority of the interrupt. The arguments are:</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>vector</DT
><DD
><P
>The interrupt whose level is to be set.</P
></DD
><DT
>level</DT
><DD
><P
>      The priority level to which the interrupt is to set. In some
      architectures the masking of an interrupt is achieved by
      changing its priority level. Hence this function,
      <TT
CLASS="FUNCTION"
>HAL_INTERRUPT_MASK()</TT
> and
      <TT
CLASS="FUNCTION"
>HAL_INTERRUPT_UNMASK()</TT
> may interfere with
      each other.
      </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN8030">Clock control</H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>HAL_CLOCK_INITIALIZE( period )
HAL_CLOCK_RESET( vector, period )
HAL_CLOCK_READ( pvalue )</PRE
></TD
></TR
></TABLE
><P
>These macros provide control over a clock or timer device that may be
used by the kernel to provide time-out, delay and scheduling
services. The clock is assumed to be implemented by some form of
counter that is incremented or decremented by some external source and
which raises an interrupt when it reaches a predetermined value.</P
><P
><TT
CLASS="FUNCTION"
>HAL_CLOCK_INITIALIZE()</TT
> initializes the timer
device to interrupt at the given period. The period is essentially the
value used to initialize the timer counter and must be calculated from
the timer frequency and the desired interrupt rate. The timer device
should generate an interrupt every <TT
CLASS="VARNAME"
>period</TT
> cycles.</P
><P
><TT
CLASS="FUNCTION"
>HAL_CLOCK_RESET()</TT
> re-initializes the timer to
provoke the next interrupt. This macro is only really necessary when
the timer device needs to be reset in some way after each interrupt.</P
><P
><TT
CLASS="FUNCTION"
>HAL_CLOCK_READ()</TT
> reads the current value of the
timer counter and puts the value in the location pointed to by
<TT
CLASS="PARAMETER"
><I
>pvalue</I
></TT
>. The value stored will always be the
number of timer cycles since the last interrupt, and hence ranges
between zero and the initial period value. If this is a count-down
cyclic timer, some arithmetic may be necessary to generate this value.</P
></DIV
><DIV
CLASS="SECTION"
><H2
CLASS="SECTION"
><A
NAME="AEN8042">Microsecond Delay</H2
><TABLE
BORDER="5"
BGCOLOR="#E0E0F0"
WIDTH="70%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>HAL_DELAY_US(us)</PRE
></TD
></TR
></TABLE
><P
>This is an optional definition. If defined the macro implements a busy
loop delay for the given number of microseconds. This is usually
implemented by waiting for the required number of hardware timer ticks
to pass. </P
><P
>This operation should normally be used when a very short delay is
needed when controlling hardware, programming FLASH devices and similar
situations where a wait/timeout loop would otherwise be used. Since it
may disable interrupts, and is implemented by busy waiting, it should
not be used in code that is sensitive to interrupt or context switch
latencies.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="hal-architecture-characterization.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecos-ref.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="hal-input-and-output.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Architecture Characterization</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="hal-interfaces.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>HAL I/O</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>